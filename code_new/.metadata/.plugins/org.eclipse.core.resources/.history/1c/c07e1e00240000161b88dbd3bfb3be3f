package pdoram;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.Random;
import message.*;
import message.Message.MessageType;

/**
*
* @author priyam.sirohi
*/


public class PDOram extends Thread {


	
	    String PDHashFunctions = "/home/nsac/anrin/ORAM/priyam/PDHashFunctions";
	    String PDoramDB = "/home/nsac/anrin/ORAM/priyam/PDoramDB";    
	    int levels, PDoramDBSize, M;
	    ObjectInputStream is;
	    ObjectOutputStream os;
	    
	    PDOrambucket[] buckets;
	    /********
	     * @param N, m
	     * @throws FileNotFoundException
	     * @throws IOException 
	     * Input : Number of entries in the mapping(N), size of each bucket(m)
	     * Output: initializes PDHashFunctions file with random values
	     * and PDoramDB file to contain all values as -1 indicating invalid entry.
	     ********/
	  
	    public PDOram(int N, int m, ObjectInputStream is,ObjectOutputStream os) throws FileNotFoundException, IOException{

	      levels = (int)(Math.log(N) / Math.log(2));
	      PDoramDBSize = N*m*2; 
	      M=m;
	      int temp;
	      buckets = new PDOrambucket[N];  
	      this.is = is;
	      this.os = os;
	      
	      
	      Random randomGenerator = new Random();
	      FileOutputStream out = new FileOutputStream(PDHashFunctions);
	      FileOutputStream out1 = new FileOutputStream(PDoramDB);
	      byte data[] =  new byte[4];
	      
	      temp = -1;
	      
	     
	      
	     for(int i=0;i<PDoramDBSize;i++){
	            
	        data[0] = (byte) (temp >> 24);
	        data[1] = (byte) (temp >> 16);
	        data[2] = (byte) (temp >> 8);
	        data[3] = (byte) (temp);

	        out1.write(data);
	        }
	     out1.close();
	        
	  
	    for(int i=0;i<2*levels;i++){
	        temp=Math.abs(randomGenerator.nextInt());

	            data[0] = (byte) (temp >> 24);
	            data[1] = (byte) (temp >> 16);
	            data[2] = (byte) (temp >> 8);
	            data[3] = (byte) (temp);
	     
	        out.write(data);
	      }
	    
	    
	}
	    /************
	     * build(ArrayList list)
	     * All the data is populated in the last level for efficiency.
	     * No collisions are assumed (collisions inside bucket are allowed).
	    ************/
	    
	    
	    
	   public int getBucketOffset(int level_num, int bucket_num){
		   
		   int offset = 0;
		   for (int i = 0; i< level_num-1;i++){
			   offset += Math.pow(2, level_num)*M*8;
		   }
		   
		   return (offset+bucket_num*M*8);
		   
	   }
	    
	    
	    public int getBucketNum(int level_num, int bucket_num){
	    	int offset = 0;
	    	for (int i = 0; i < level_num; i++){
	    		offset += Math.pow(2,i);
	    	}
	    	
	    	offset += bucket_num;
	    	
	    	return offset;
	    }
	    
	    
	    
	   public void build(ArrayList list) throws FileNotFoundException, IOException{
	        int a=-1,b=-1, temp;
	        byte data[] =  new byte[4];
	        
	        FileInputStream inhash = new FileInputStream(PDHashFunctions);
	        inhash.skip(8*(levels-1));
	        for(int j=0;j<2;j++){
	            temp=0;
	             for (int i = 0; i < 4; i++) {
	                int shift = (4 - 1 - i) * 8;
	                temp += (inhash.read() & 0x000000FF) << shift;
	            }
	            if(a==-1) a = temp;
	            else b = temp;
	        }
	        
	        
	        
	        RandomAccessFile out = new RandomAccessFile(PDoramDB, "rw");
	        RandomAccessFile in = new RandomAccessFile(PDoramDB, "rw");
	        int entry_counter = 1;
	       
	        for (int i = 0; i<levels-1;i++){
	        	for (int j = 0; j< Math.pow(2, i);j++){
	        		int val = (int) list.get(entry_counter);
	        		int hash = (a*entry_counter + b)%((int)Math.pow(2,i)); 
	        		for (int k = 0; k < M; k++){
	        			if (this.buckets[getBucketNum(i,hash)].getMap()[j] == -1){
	        				this.buckets[getBucketNum(i,hash)].setMapIndex(j, entry_counter++);
	        				this.buckets[getBucketNum(i,hash)].setBucketIndex(j, val);
	        			}
	        			
	        		}
	        		
	        		in.skipBytes(getBucketOffset(i,hash)); // Writing Bucket-wise	
	        		 int writeOffset = (int) (in.getFilePointer()-4);
	        		 out.skipBytes(writeOffset);
	        	}
	        }	
	        	
	        	
	        	
	        	
	        	
	        	
	        	
		        	 for(int j=0;j<M;j++){
			             temp=0;
			             for (int k = 0; k < 4; k++) {
			                int shift = (4 - 1 - k) * 8;
			                temp += (in.read() & 0x000000FF) << shift;
			            }
			             if(temp == -1) break;  
			             else {
			                 in.skipBytes(4);
			             }
			         }
		        	 int writeOffset = (int) (in.getFilePointer()-4);
			        			         
			          
			          out.skipBytes(writeOffset);
			          
			         data[0] = (byte) (entry_counter >> 24);
			            data[1] = (byte) (entry_counter >> 16);
			            data[2] = (byte) (entry_counter >> 8);
			            data[3] = (byte) (entry_counter);
			     
			        out.write(data);
			        
			        data[0] = (byte) (val >> 24);
			            data[1] = (byte) (val >> 16);
			            data[2] = (byte) (val >> 8);
			            data[3] = (byte) (val);
			     
			        out.write(data);	 
		        	
	        }
	        
	        in.close();
	        out.close();
	}
	        
	        
	    /*    
	        
	        for(int i=0; i<list.size();i++){
	         int writeOffset = 0;
	         RandomAccessFile in = new RandomAccessFile(PDoramDB, "rw");
	         in.skipBytes((int)(Math.pow(2,levels-1)-1)*M*8); //now I am at the starting of the last level
	         
	         
	         @SuppressWarnings("unchecked")
			ArrayList<Integer> list1 = (ArrayList<Integer>) list.get(i);
	         int id = list1.get(0);
	         int val = list1.get(1);
	         
	         int hash = (a*id + b)%((int)Math.pow(2,levels-1)); // we have to put the data into hashth bucket.
	         
	         
	         
	         
	         // go to the starting of hashth bucket
	         in.skipBytes(hash*M*8);
	         
	      */   
	        
	        
	    
	    
	    public  int PDOramRead(int id,int clientID,int messageID) throws FileNotFoundException, IOException, ClassNotFoundException{
	        
	    int val =-1;
	    RandomAccessFile PDHash = new RandomAccessFile(PDHashFunctions, "rw");
	    RandomAccessFile PDDB = new RandomAccessFile(PDoramDB, "rw");
	    
	    int a, b, skipBefore, skipAfter, hash;
	    
	    
	    for(int i=0; i< levels; i++){
	       a = PDHash.readInt();
	       b = PDHash.readInt();
	      
	       hash = Math.abs((a*id + b)%(1<<i));
	       
	       PDoram_getBucket pdgb = new PDoram_getBucket(clientID,messageID,i,hash);
	       
	       os.writeObject(pdgb);
	       os.flush();
	       os.reset();
	       Message ms = (Message) is.readObject();
	       
	       
	       while(ms.getMessageType().compareTo(MessageType.PDoram_GetBucket)!= 0){
	    	   Thread.yield();
	       }
	       
	        PDoram_getBucket new_pgdb = (PDoram_getBucket) ms;    	   
	    	   
	        
	    	   /* Client side computation */
	       
	       /*skipBefore = 8*hash*M;
	       skipAfter = 8*M*((1<<i) -(hash+1));
	       PDDB.skipBytes(skipBefore);
	       */
	       
	        
	      for(int j =0;j<M;j++){
	        if(new_pgdb.getBucket().getBucket().get(j)
	    	  
	    	  
	    	  
	    	  
	    	  
	    	  
	    	  
	    	  
	    	  
	    	  
	    	  
	    	  
	    	  if( PDDB.readInt()==id){
	                  	  
	        	  return PDDB.readInt();
	          }
	          else PDDB.skipBytes(4);
	      }

	       PDDB.skipBytes(skipAfter);
	    }
	    
	    PDHash.close();
	    PDDB.close();
	    
	    return val;
	    }
	}
	

